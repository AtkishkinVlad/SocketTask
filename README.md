# SocketTask

## Компиляция и запуск

Программа компилируется командой `make`

Запуск программы осуществляется одним из трех образов:

1) **В качестве сервера**

`./result -s`

Сервер создает socket с именем файла ‘/tmp/my_server_socket’. Если этот файл в момент запуска сервера уже существует, сервер окончит работу с записью в лог-файл сообщения об ошибке. Лог-файл сервера ‘server_log.txt’ в рабочей папке программы.

2) **В качестве клиента с задержкой 0.2, номером клиента 5 (нужен для информативности записей в логах) и отправкой серверу содержимого 1000 случайных чисел (общей суммой нуль) из файла ‘data.txt’.** 

Для корректной работы клиента сервер должен быть уже запущен.
`./result -c 0.2 5 < data.txt`

У клиента с номером 5 лог-файл ‘client_log_000005.txt’.

3) **В качестве клиента, который не делает ничего, кроме выяснения и распечатки внутреннего состояния сервера.** 

> Для корректной работы сервер должен работать !

## Тестирование

1) Скрипт `clean.sh` очищает папку от лог-файлов

2) Скрипт `startClients.sh` должен запускаться с двумя параметрами при уже работающем сервере:
`source starctClients.sh 0.2 100`
- данная команда запускает сотню клиентов с задержками величиной 0.2 секунды и ожидает их завершения.

3) Скрипт `effectiveTime.sh` читает имеющиеся в рабочей папке логи сервера и клиентов и определяет максимальную суммарную задержку для всех клиентов и длительность последнего активного периода работы сервера. Эти величины равны друг другу с хорошой точностью, что доказывает корректную реализацию асинхронности сервера.

4) Скрипт `runtime1.sh` запускает сервер, десятикратно запускает сотню клиентов и ожидает их завершения. Затем убивает сервер и анализирует его логи – на предмет используемых номеров файловых дескрипторов и границ кучи в момент первого и последнего входящего соединения. 

5) Скрипт `runtime2.sh` запускает сервер, затем несколько раз различные группы клиентов с различными задержками. По окончании работы каждой группы клиентов сравниваются максимальная суммарная задержка и длительность последнего периода активной работы сервера; выясняется внутреннее соостояние сервера. Затем сервер убивается.

